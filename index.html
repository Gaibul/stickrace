<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stick Figure Parkour — Multiplayer</title>
<style>
  html, body { height: 100%; margin: 0; background: #0f1222; color: #e8ecf1; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  canvas { display:block; width: 100vw; height: 100vh; image-rendering: pixelated; }
  #ui { position: fixed; inset: 0 0 auto 0; display: flex; gap: 12px; align-items: center; padding: 10px 14px;
        background: linear-gradient(180deg, rgba(15,18,34,.9), rgba(15,18,34,.25), rgba(15,18,34,0)); pointer-events: none; }
  .pill { pointer-events: auto; background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.12); padding: 8px 12px; border-radius: 999px; font-weight: 600; backdrop-filter: blur(6px); }
  .spacer { flex: 1; }
  button { cursor: pointer; pointer-events: auto; background: #1b203d; color: #e8ecf1; border: 1px solid rgba(255,255,255,.12); padding: 8px 12px; border-radius: 10px; font-weight: 700; }
  #help { position: fixed; right: 10px; bottom: 10px; font-size: 12px; opacity: .85; background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.12); padding: 6px 10px; border-radius: 8px; }
  #lobby { position: fixed; inset: 0; background: rgba(0,0,0,0.92); display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 10px; }
  #lobby .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 16px; width: min(460px, 92vw); }
  input, button, select { margin: 4px 0; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.15); background: #161a31; color: #e8ecf1; width: 100%; box-sizing: border-box; }
  #leaderboard span.badge, #seriesboard span.badge { background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding: 2px 8px; border-radius: 999px; margin-right: 6px; display:inline-block; }
</style>
<!-- Firebase compat (v8.x API) -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
</head>
<body>
  <!-- Lobby -->
  <div id="lobby">
    <div class="card">
      <h2 style="margin:0 0 8px 0;">Stick Parkour — Multiplayer</h2>
      <div style="display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center;">
        <input id="nameInput" placeholder="Your name" />
        <input type="color" id="colorInput" value="#ff3b3b" style="width:56px; padding:0; height:42px; border-radius:10px;" />
      </div>
      <button id="createRoom">Create Room</button>
      <div style="display:flex; gap:8px; margin-top:6px;">
        <input id="joinCode" placeholder="Room code (e.g., ABC123)" />
        <button id="joinRoom" style="width:auto;">Join</button>
      </div>
      <div style="opacity:.8; font-size:12px; margin-top:6px;">Tip: Share the 6-letter code so friends can join.</div>
    </div>
  </div>

  <!-- In-game UI -->
  <div id="ui" style="display:none">
    <div class="pill">🧩 Room: <span id="roomCode">—</span></div>
    <div class="pill">🎲 Seed: <span id="seed">—</span></div>
    <div class="pill">🔁 Round: <span id="roundIdx">1</span></div>
    <div class="pill">⏱️ Your Time: <span id="time">0.000</span>s</div>
    <div class="pill" id="hostOnly" style="display:none; gap:8px;">
      <button id="newLevelBtn">New Level</button>
      <button id="restartBtn">Restart</button>
    </div>
    <div class="spacer"></div>
    <div class="pill">🏁 Leaderboard: <span id="leaderboard"></span></div>
    <div class="pill">🏆 Series: <span id="seriesboard"></span></div>
  </div>

  <div id="help">Move: A/D or ⬅️/➡️ · Jump: W/⬆️/Space · Hold for higher jump · R Restart (you) · N (host): New Level · Shift: Push nearby player (2s cd) · Touch lava = reset</div>
  <canvas id="game"></canvas>

<script>
/* -------------------------------- Firebase setup -------------------------------- */
const firebaseConfig = {
  apiKey: "AIzaSyAEqutXCO5OZD6VU_ohaBxNfh7G8Q6PEy0",
  authDomain: "nomercy-8269a.firebaseapp.com",
  databaseURL: "https://nomercy-8269a-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "nomercy-8269a",
  storageBucket: "nomercy-8269a.firebasestorage.app",
  messagingSenderId: "349047620790",
  appId: "1:349047620790:web:3206ff81cb7f5413d29217",
  measurementId: "G-1WX7CWBFGF"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ------------------------------- Multiplayer state ------------------------------- */
const localId = Math.random().toString(36).slice(2, 11);
let localName = "";
let localColor = "#ff3b3b";
let roomId = null;
let hostId = null;
let seed = 0;
let players = {};      // realtime snapshot of room players
let leaderboard = {};  // id -> {name, time}
let seriesScores = {}; // id -> {name, points}
let roundIdx = 1;
let isHost = false;

// UI refs
const lobby = document.getElementById('lobby');
const nameInput = document.getElementById('nameInput');
const colorInput = document.getElementById('colorInput');
const roomCodeEl = document.getElementById('roomCode');
const seedEl = document.getElementById('seed');
const timeEl = document.getElementById('time');
const lbEl = document.getElementById('leaderboard');
const seriesEl = document.getElementById('seriesboard');
const roundIdxEl = document.getElementById('roundIdx');
const hostOnly = document.getElementById('hostOnly');
const newLevelBtn = document.getElementById('newLevelBtn');
const restartBtn = document.getElementById('restartBtn');
newLevelBtn.onclick = () => hostNewLevel();
restartBtn.onclick = () => restartLocal();

document.getElementById('createRoom').onclick = createRoom;
document.getElementById('joinRoom').onclick = joinExistingRoom;

/* Create room (host) */
async function createRoom() {
  try {
    localName = (nameInput.value || "Player").slice(0, 18);
    localColor = colorInput.value || "#ff3b3b";
    const code = Math.random().toString(36).substr(2,6).toUpperCase();

    seed = Math.floor(Math.random()*1e9);
    roomId = code;
    hostId = localId;
    isHost = true;

    await db.ref(`rooms/${roomId}`).set({
      seed: seed,
      hostId: hostId,
      started: true,
      leaderboard: {},
      scores: {},
      roundIndex: 1
    });

    await joinRoomInternal(roomId);
  } catch (err) {
    console.error("createRoom error", err);
    alert("Create Room failed: " + (err && err.message ? err.message : err));
  }
}

/* Join an existing room */
async function joinExistingRoom() {
  try {
    localName = (nameInput.value || "Player").slice(0, 18);
    localColor = colorInput.value || "#ff3b3b";
    const code = (document.getElementById('joinCode').value || "").toUpperCase();
    if (!code) { alert("Enter a room code"); return; }

    const snap = await db.ref(`rooms/${code}`).get();
    if (!snap.exists()) { alert("Room not found"); return; }

    roomId = code;
    const val = snap.val();
    seed = val.seed;
    hostId = val.hostId || null;
    isHost = (hostId === localId); // typically false for joiners

    await joinRoomInternal(roomId);
  } catch (err) {
    console.error("joinExistingRoom error", err);
    alert("Join Room failed: " + (err && err.message ? err.message : err));
  }
}

/* Attach listeners, register presence */
async function joinRoomInternal(code) {
  roomId = code;
  lobby.style.display = 'none';
  if (P) P.running = false; // stop practice once in a room
  document.getElementById('ui').style.display = 'flex';
  roomCodeEl.textContent = roomId;
  seedEl.textContent = seed;

  // Add self to players; ensure removal on disconnect
  const playerRef = db.ref(`rooms/${roomId}/players/${localId}`);
  await playerRef.set({
    name: localName, color: localColor,
    x: 0, y: 0, vx: 0, vy: 0, finished: false, time: 0
  });
  playerRef.onDisconnect().remove();

  // players
  db.ref(`rooms/${roomId}/players`).on('value', snap => {
    players = snap.val() || {};
  });

  // per-level leaderboard
  db.ref(`rooms/${roomId}/leaderboard`).on('value', snap => {
    leaderboard = snap.val() || {};
    renderLeaderboard();
  });

  // series scores across levels
  db.ref(`rooms/${roomId}/scores`).on('value', snap => {
    seriesScores = snap.val() || {};
    renderSeriesboard();
  });

  // round index
  db.ref(`rooms/${roomId}/roundIndex`).on('value', snap => {
    roundIdx = snap.val() || 1;
    roundIdxEl.textContent = roundIdx;
  });

  // new seed from host
  db.ref(`rooms/${roomId}/seed`).on('value', snap => {
    const newSeed = snap.val();
    if (typeof newSeed === 'number' && newSeed !== seed) {
      seed = newSeed;
      seedEl.textContent = seed;
      finished = false;
      generateLevel(seed);
      restartLocal();
    }
  });

  // hostId changes
  db.ref(`rooms/${roomId}/hostId`).on('value', snap => {
    hostId = snap.val();
    isHost = (hostId === localId);
    hostOnly.style.display = isHost ? 'inline-flex' : 'none';
  });

  // push impulses (fun)
  db.ref(`rooms/${roomId}/impulses`).on('child_added', snap => {
    const imp = snap.val();
    if (imp && imp.to === localId) {
      player.vx += imp.vx;
      player.vy += imp.vy;
    }
  });

  startGame();
  hostOnly.style.display = (hostId === localId) ? 'inline-flex' : 'none';
}

/* Host-only: set a new seed + clear leaderboard + reset finished flags */
async function hostNewLevel() {
  if (!roomId) return;
  if (!isHost) { alert('Only the host can start a new level.'); return; }
  // award points for the round that just ended
  await awardRoundPoints();
  // compute next round index
  let nextIdx = 1;
  try {
    const idxSnap = await db.ref(`rooms/${roomId}/roundIndex`).get();
    nextIdx = ((idxSnap.val()|0) + 1) || 1;
  } catch(e){}
  // new seed & clear current leaderboard, set next round
  const newSeed = Math.floor(Math.random()*1e9);
  await db.ref(`rooms/${roomId}`).update({ seed: newSeed, leaderboard: {}, roundIndex: nextIdx });
  // Reset each player's finished/time
  const pSnap = await db.ref(`rooms/${roomId}/players`).get();
  if (pSnap.exists()) {
    const vals = pSnap.val();
    await Promise.all(Object.keys(vals).map(pid =>
      db.ref(`rooms/${roomId}/players/${pid}`).update({ finished:false, time:0 })
    ));
  }
}

/* Update the leaderboard UI */
function renderLeaderboard() {
  const rows = Object.entries(leaderboard).map(([pid, row]) => ({ pid, name: row.name || 'Player', time: +row.time || 0 }));
  rows.sort((a,b)=> a.time - b.time);
  lbEl.innerHTML = rows.map(r => `<span class="badge">${escapeHTML(r.name)} — ${r.time.toFixed(3)}s</span>`).join(' ');
}
function renderSeriesboard(){
  const rows = Object.entries(seriesScores).map(([pid, row]) => ({ pid, name: row.name || 'Player', points: +row.points || 0 }));
  rows.sort((a,b)=> a.points - b.points || (a.name||'').localeCompare(b.name||''));
  seriesEl.innerHTML = rows.map(r => `<span class="badge">${escapeHTML(r.name)} — ${r.points} pts</span>`).join(' ');
}
function escapeHTML(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#039;'}[c])); }

/* ------------------------------ World/Viewport scaling ------------------------------ */
// All players must simulate the SAME world units regardless of their window size.
// We draw in a canonical world where HEIGHT = WORLD_H. The canvas transform scales
// to the actual device pixels so positions from any client match.
const WORLD_H = 900; // logical world height in units (same for everyone)
let VIEW_SCALE = 1;  // pixels per world unit (varies per device)
let VIEW_W = 0;      // viewport width in world units
let VIEW_H = 0;      // viewport height in world units

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function fit() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  VIEW_SCALE = innerHeight / WORLD_H; // uniform scale for x & y
  VIEW_W = innerWidth / VIEW_SCALE;
  VIEW_H = innerHeight / VIEW_SCALE;
  canvas.width = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  // draw everything in WORLD units; browser scales to pixels
  ctx.setTransform(dpr*VIEW_SCALE, 0, 0, dpr*VIEW_SCALE, 0, 0);
}
addEventListener('resize', fit, {passive:true});
fit();

/* ------------------------------ Game implementation ------------------------------ */
const TAU = Math.PI * 2;
function makeRNG(seed){ return () => (seed = (seed * 1664525 + 1013904223) >>> 0) / 2**32; }

const WORLD = {
  gravity: 2600,
  maxFall: 3000,
  groundFric: 1800,
  airFric: 200,
  runAccel: 3500,
  maxSpeed: 500,
  airControl: 0.6,
  jumpVel: 750,
  shortHopCut: 0.5,
  coyoteTime: 0.10,
  jumpBuffer: 0.10,
  stepHeight: 8
};

const player = { x:0,y:0,w:20,h:52, vx:0,vy:0, onGround:false, lastGroundTime:-999, lastJumpPress:-999, facing:1, runCycle:0, landedAt:0 };

let keys = new Set();
let lastPushAt = 0; // ms
const PUSH_COOLDOWN = 2000; // 2s
const PUSH_RADIUS = 60; // world units
const PUSH_IMP_VX = 700; // horizontal impulse
const PUSH_IMP_VY = -420; // pop up a little

function isTyping(){
  const el = document.activeElement;
  if (!el) return false;
  const tag = el.tagName;
  return el.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
}
addEventListener('keydown', (e)=>{
  const typing = isTyping();
  if (!typing && ["ArrowUp","ArrowLeft","ArrowRight","Space","KeyA","KeyD","KeyW","KeyR","KeyN","ShiftLeft","ShiftRight"].includes(e.code)) e.preventDefault();
  if (typing) return;
  keys.add(e.code);
  if (e.code === 'Space' || e.code === 'KeyW' || e.code === 'ArrowUp') player.lastJumpPress = timeNow;
  if (e.code === 'KeyR') { if (roomId) restartLocal(); else practiceRestart(); }
  if (e.code === 'KeyN') { if (roomId) hostNewLevel(); else practiceNewLevel(); }
  if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && roomId) tryPush();
});
addEventListener('keyup', (e)=>{ if (isTyping()) return; keys.delete(e.code); });

/* ------------------------ Practice map while in lobby ------------------------ */
const P = {
  running: true,
  seed: Math.floor(Math.random()*1e9),
  player: { x:0,y:0,w:20,h:52, vx:0,vy:0, onGround:false, lastGroundTime:-999, lastJumpPress:-999, facing:1, runCycle:0, landedAt:0 },
  platforms: [], walls: [], lava: [], startX:0, startY:0,
  goalX:0, goalY:0, goalW:60, goalH:12,
  last: performance.now(), t: 0
};
function maxHorizDistanceForDeltaY(deltaY){
  const J = WORLD.jumpVel, g = WORLD.gravity;
  const A = 0.5*g, B = -J, C = -deltaY;
  const disc = B*B - 4*A*C; if (disc < 0) return 0;
  const t = (-B + Math.sqrt(disc)) / (2*A);
  const vx = WORLD.maxSpeed * 0.95;
  return vx * t;
}
function generatePracticeLevel(seed){
  const R = makeRNG(seed);
  const segs = [], newWalls = [], newLava = [];
  const groundY = Math.round(WORLD_H*0.62);
  const startPlat = {x: 0, y: groundY, w: 260, h: 18};
  segs.push(startPlat);
  const minY = 80;
  const maxY = Math.min(WORLD_H - 140, groundY + 80);
  const floorY = Math.min(maxY+100, WORLD_H-20);
  let cursorX = startPlat.x + startPlat.w;
  let cursorY = startPlat.y;
  const targetLen = 1400;
  while (cursorX < targetLen){
    const dY = (R() < 0.55 ? (R()*140) : -(R()*90));
    let newY = Math.max(minY, Math.min(maxY, cursorY + dY));
    if (newY > floorY - 160) newY = floorY - 160;
    const maxDx = maxHorizDistanceForDeltaY(newY - cursorY) * 0.85;
    const minDx = Math.max(90, maxDx*0.35);
    let dx = Math.max(80, isFinite(maxDx) ? (minDx + R()*(maxDx - minDx)) : 120);
    const plat = {x: Math.round(cursorX + dx), y: Math.round(newY), w: 150 + Math.floor(R()*110), h: 18};
    segs.push(plat);
    if (R()<0.6){
      const gapStart = cursorX + 10, gapEnd = plat.x - 10, gapW = Math.max(0, gapEnd-gapStart);
      if (gapW > 80){
        const pitW = Math.min(gapW - 40, 160 + R()*180);
        const pitX = gapStart + 20 + R()*(gapW - pitW - 40);
        newLava.push({x: Math.round(pitX), y: floorY-12, w: Math.round(pitW), h: 12});
      }
    }
    if (R()<0.25){
      const wallH = 40 + Math.floor(R()*60);
      const wx = Math.round(plat.x + 60 + R()*Math.max(20, plat.w-120));
      newWalls.push({x: wx, y: plat.y - wallH, w: 16, h: wallH});
    }
    cursorX = plat.x + plat.w;
    cursorY = plat.y;
  }
  const goalPlat = {x: cursorX + 120, y: Math.max(minY+40, cursorY - 40), w: 200, h: 18};
  segs.push(goalPlat);
  newLava.push({x: goalPlat.x - 120, y: floorY-12, w: goalPlat.w + 240, h: 12});
  P.goalX = goalPlat.x + goalPlat.w - P.goalW - 16;
  P.goalY = goalPlat.y - P.goalH;
  segs.push({x: -1000, y: floorY, w: cursorX+2000, h: 200});
  P.platforms = segs; P.walls = newWalls; P.lava = newLava;
  P.startX = startPlat.x + 20; P.startY = startPlat.y - P.player.h;
}
function practiceRestart(){
  const pl = P.player; pl.x=P.startX; pl.y=P.startY; pl.vx=0; pl.vy=0; pl.onGround=false; P.t=0;
}
function practicePhysics(dt){
  const pl = P.player;
  const left = keys.has('ArrowLeft') || keys.has('KeyA');
  const right = keys.has('ArrowRight') || keys.has('KeyD');
  const jumpPressed = (keys.has('Space') || keys.has('KeyW') || keys.has('ArrowUp'));
  const desired = (right?1:0) - (left?1:0);
  const accel = pl.onGround ? WORLD.runAccel : WORLD.runAccel*WORLD.airControl;
  pl.vx += desired * accel * dt;
  if (!left && !right){ const fric = pl.onGround ? WORLD.groundFric : WORLD.airFric; if (Math.abs(pl.vx) <= fric*dt) pl.vx=0; else pl.vx -= Math.sign(pl.vx)*fric*dt; }
  pl.vx = Math.max(-WORLD.maxSpeed, Math.min(WORLD.maxSpeed, pl.vx));
  if (right) pl.facing = 1; else if (left) pl.facing = -1;
  pl.vy += WORLD.gravity * dt; if (pl.vy > WORLD.maxFall) pl.vy = WORLD.maxFall;
  if (jumpPressed) pl.lastJumpPress = P.t;
  const canJump = (P.t - pl.lastJumpPress) <= WORLD.jumpBuffer && (pl.onGround || (P.t - pl.lastGroundTime) <= WORLD.coyoteTime);
  if (canJump) { pl.vy = -WORLD.jumpVel; pl.onGround = false; pl.lastJumpPress = -999; }
  if (!jumpPressed && pl.vy < 0) pl.vy += WORLD.gravity * WORLD.shortHopCut * dt;
  let newX = pl.x + pl.vx * dt; let newY = pl.y + pl.vy * dt; pl.onGround = false;
  const solids = P.platforms.concat(P.walls);
  const boundsX = {x: Math.min(pl.x, newX), y: pl.y, w: pl.w + Math.abs(pl.vx*dt), h: pl.h};
  for (const s of solids){ if (!(boundsX.x < s.x+s.w && boundsX.x+boundsX.w > s.x && boundsX.y < s.y+s.h && boundsX.y+boundsX.h > s.y)) continue; if (newX < s.x+s.w && newX+pl.w > s.x && pl.y < s.y+s.h && pl.y+pl.h > s.y){ if (pl.vx > 0) newX = s.x - pl.w; else if (pl.vx < 0) newX = s.x + s.w; pl.vx = 0; } }
  const boundsY = {x: newX, y: Math.min(pl.y, newY), w: pl.w, h: pl.h + Math.abs(pl.vy*dt)};
  let grounded = false;
  for (const s of solids){ if (!(boundsY.x < s.x+s.w && boundsY.x+boundsY.w > s.x && boundsY.y < s.y+s.h && boundsY.y+boundsY.h > s.y)) continue; if (newX < s.x+s.w && newX+pl.w > s.x && newY < s.y+s.h && newY+pl.h > s.y){ if (pl.vy > 0){ newY = s.y - pl.h; pl.vy = 0; grounded = true; } else if (pl.vy < 0){ newY = s.y + s.h; pl.vy = 0; } } }
  pl.x = newX; pl.y = newY; if (grounded){ pl.onGround = true; pl.lastGroundTime = P.t; pl.landedAt = P.t; }
  for (const l of P.lava){ if (pl.x < l.x+l.w && pl.x+pl.w > l.x && pl.y < l.y+l.h && pl.y+pl.h > l.y){ practiceRestart(); break; } }
  const speed = Math.abs(pl.vx); if (pl.onGround && speed > 10) pl.runCycle = (pl.runCycle + dt * (0.6 + 0.004*speed)) % 1; else if (!pl.onGround) pl.runCycle = pl.runCycle; else pl.runCycle = (pl.runCycle*0.92);
}
function drawPractice(){
  const cw = VIEW_W, ch = VIEW_H;
  const camX = Math.floor(P.player.x - cw*0.35), camY = 0;
  const grd = ctx.createLinearGradient(0,0,0,ch); grd.addColorStop(0,'#0f1222'); grd.addColorStop(1,'#12162a'); ctx.fillStyle=grd; ctx.fillRect(0,0,cw,ch);
  ctx.globalAlpha = 0.25; ctx.fillStyle='#b6c4ff'; for (let i=0;i<80;i++){ const sx=(i*1231.7 % 3000) - (camX*0.2 % 3000); const sy=(i*811.3 % ch); ctx.fillRect((sx%(cw+300))-150, sy, 2, 2);} ctx.globalAlpha=1;
  for (const p of P.platforms){ if (p.x + p.w < camX-50 || p.x > camX+cw+50) continue; const x=p.x-camX, y=p.y-camY; ctx.fillStyle='#222947'; ctx.fillRect(x,y,p.w,p.h); ctx.fillStyle='#2e3763'; ctx.fillRect(x,y,p.w,4); }
  for (const w of P.walls){ if (w.x + w.w < camX-50 || w.x > camX+cw+50) continue; const x=w.x-camX, y=w.y-camY; ctx.fillStyle='#1a1f3a'; ctx.fillRect(x,y,w.w,w.h); ctx.fillStyle='#34406e'; ctx.fillRect(x,y,w.w,4); }
  for (const l of P.lava){ if (l.x + l.w < camX-50 || l.x > camX+cw+50) continue; const x=l.x-camX, y=l.y-camY, t=P.t*5; const grad=ctx.createLinearGradient(0,y,0,y+l.h); grad.addColorStop(0,'#ffdb6e'); grad.addColorStop(0.4,'#ff7b3a'); grad.addColorStop(1,'#b1120d'); ctx.fillStyle=grad; ctx.fillRect(x,y,l.w,l.h); ctx.beginPath(); const A=3; ctx.moveTo(x,y); for (let i=0;i<=l.w;i+=8){ const wy = y + Math.sin((i*0.12)+t)*A; ctx.lineTo(x+i, wy);} ctx.lineTo(x+l.w,y+l.h); ctx.lineTo(x,y+l.h); ctx.closePath(); ctx.fillStyle='rgba(255,255,255,0.1)'; ctx.fill(); }
  ctx.fillStyle='#ffcf4b'; ctx.fillRect(P.goalX - camX, P.goalY - camY, P.goalW, P.goalH);
  ctx.fillStyle = '#e8ecf1'; ctx.fillRect(P.goalX - camX + P.goalW/2-2, P.goalY - 50 - camY, 4, 50);
  ctx.beginPath(); ctx.moveTo(P.goalX - camX + P.goalW/2+2, P.goalY - 50 - camY); ctx.lineTo(P.goalX - camX + P.goalW/2+32, P.goalY - 40 - camY); ctx.lineTo(P.goalX - camX + P.goalW/2+2, P.goalY - 30 - camY); ctx.closePath(); ctx.fill();
  const previewColor = (colorInput && colorInput.value) ? colorInput.value : '#e8ecf1';
  drawStick(P.player.x - camX + P.player.w/2, P.player.y - camY, P.player, previewColor, P.t);
  ctx.save(); ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign='center'; ctx.fillStyle=previewColor; const nm=(nameInput && nameInput.value ? nameInput.value : 'You').slice(0,14); ctx.fillText(nm, P.player.x - camX + P.player.w/2, P.player.y - camY - 56); ctx.restore();
}
function practiceLoop(now){ if (!P.running) return; const dtRaw=(now - P.last)/1000; P.last=now; const dt=Math.min(1/30, Math.max(0, dtRaw)); P.t += dt; practicePhysics(dt); drawPractice(); requestAnimationFrame(practiceLoop); }
function startPractice(){ generatePracticeLevel(P.seed); practiceRestart(); requestAnimationFrame(practiceLoop); }
function practiceNewLevel(){ P.seed = Math.floor(Math.random()*1e9); generatePracticeLevel(P.seed); practiceRestart(); }

// Level data
let platforms = [], walls = [], lavaPools = [];
let startX=0, startY=0, goalX=0, goalY=0, goalW=60, goalH=12;
let timeNow = 0, timeStart = 0, finished = false, deathFlashUntil = -1;

function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){ return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by; }
function killPlayer(){ deathFlashUntil = timeNow + 0.25; restartLocal(); }

function tryPush(){
  const now = performance.now();
  if (now - lastPushAt < PUSH_COOLDOWN) return;
  let targetId = null, bestD2 = PUSH_RADIUS*PUSH_RADIUS;
  for (const [pid, p] of Object.entries(players)){
    if (pid === localId) continue;
    const dx = (p.x||0) - player.x;
    const dy = (p.y||0) - player.y;
    const d2 = dx*dx + dy*dy;
    if (d2 <= bestD2) { bestD2 = d2; targetId = pid; }
  }
  if (!targetId) return;
  const p = players[targetId];
  const dirX = Math.sign((p.x||0) - player.x) || (player.facing||1);
  const impulse = { from: localId, to: targetId, vx: dirX * PUSH_IMP_VX, vy: PUSH_IMP_VY, at: Date.now() };
  db.ref(`rooms/${roomId}/impulses`).push(impulse);
  lastPushAt = now;
}

/* ---- scoring helpers ---- */
function calculateRoundPoints(playersObj, lbObj, oldScores){
  const scores = { ...(oldScores||{}) };
  const playerIds = Object.keys(playersObj||{});
  const nPlayers = playerIds.length || 0;
  const finList = Object.entries(lbObj||{})
    .filter(([pid, row]) => typeof row.time === 'number' && isFinite(row.time))
    .sort((a,b)=> a[1].time - b[1].time);
  // Award finishers 1..k
  finList.forEach(([pid, row], i) => {
    const prev = (scores[pid]?.points)|0;
    const name = (playersObj[pid]?.name) || row.name || scores[pid]?.name || 'Player';
    scores[pid] = { name, points: prev + (i+1) };
  });
  // DNFs get nPlayers points
  for (const pid of playerIds){
    if (finList.find(([id])=>id===pid)) continue;
    const prev = (scores[pid]?.points)|0;
    const name = (playersObj[pid]?.name) || scores[pid]?.name || 'Player';
    scores[pid] = { name, points: prev + (nPlayers || 1) };
  }
  return scores;
}
async function awardRoundPoints(){
  const [pSnap, lbSnap, scSnap] = await Promise.all([
    db.ref(`rooms/${roomId}/players`).get(),
    db.ref(`rooms/${roomId}/leaderboard`).get(),
    db.ref(`rooms/${roomId}/scores`).get()
  ]);
  const playersObj = pSnap.val() || {};
  const lbObj = lbSnap.val() || {};
  const oldScores = scSnap.val() || {};
  const newScores = calculateRoundPoints(playersObj, lbObj, oldScores);
  await db.ref(`rooms/${roomId}/scores`).set(newScores);
}

function generateLevel(wSeed){
  const R = makeRNG(wSeed);
  const segs = [], newWalls = [], newLava = [];

  const groundY = Math.round(WORLD_H*0.58);
  const startPlat = {x: 0, y: groundY, w: 240, h: 18};
  segs.push(startPlat);

  const targetLen = 4200; // fixed logical width so all clients match
  const minY = 80;
  const maxY = Math.min(WORLD_H - 140, groundY + 100);
  const floorY = Math.min(maxY+100, WORLD_H-20);

  let cursorX = startPlat.x + startPlat.w;
  let cursorY = startPlat.y;

  while (cursorX < targetLen) {
    const maxUp = 120, maxDown = 190;
    let dY = (R() < 0.55 ? (R()*maxDown) : -(R()*maxUp));
    let newY = Math.max(minY, Math.min(maxY, cursorY + dY));
    if (newY > floorY - 160) newY = floorY - 160;
    dY = newY - cursorY;

    const maxDx = maxHorizDistanceForDeltaY(dY) * 0.85;
    const minDx = Math.max(90, maxDx*0.35);
    let dx = minDx + R()*(maxDx - minDx);
    if (!isFinite(dx) || dx < 80) { dx = 120; newY = cursorY; dY = 0; }

    const platW = 160 + Math.floor(R()*140);
    const platH = 18;
    const plat = {x: Math.round(cursorX + dx), y: Math.round(newY), w: platW, h: platH};

    if (dY < -60 && R() < 0.6) {
      const midX = (cursorX + plat.x)/2;
      const midY = Math.round(cursorY - Math.min(40, -dY*0.6));
      const mid = {x: Math.round(midX-60), y: midY, w: 120, h: 14};
      const ok1 = (mid.x - (cursorX)) <= maxHorizDistanceForDeltaY(mid.y - cursorY);
      const ok2 = (plat.x - (mid.x+mid.w)) <= maxHorizDistanceForDeltaY(plat.y - mid.y);
      if (ok1 && ok2) segs.push(mid);
    }

    if (R() < 0.65) {
      const gapStart = cursorX + 10;
      const gapEnd = plat.x - 10;
      const gapW = Math.max(0, gapEnd - gapStart);
      if (gapW > 60) {
        const pitW = Math.min(gapW - 40, 200 + R()*280);
        const pitX = gapStart + 20 + R()*(gapW - pitW - 40);
        newLava.push({x: Math.round(pitX), y: floorY-12, w: Math.round(pitW), h: 12});
        if (gapW - pitW > 180 && R() < 0.35) {
          const pit2W = Math.min(gapW - pitW - 100, 160 + R()*240);
          const pit2X = pitX + pitW + 60;
          if (pit2W > 80) newLava.push({x: Math.round(pit2X), y: floorY-12, w: Math.round(pit2W), h: 12});
        }
      }
    }

    segs.push(plat);

    if (R() < 0.25 && plat.w > 100) {
      const maxLavaW = Math.floor(plat.w * 0.15);
      const minLavaW = Math.max(16, Math.floor(maxLavaW * 0.5));
      if (maxLavaW > minLavaW) {
        const margin = 20;
        const lavaW = Math.floor(minLavaW + R() * (maxLavaW - minLavaW));
        const range = Math.max(0, plat.w - lavaW - margin*2);
        const lavaX = Math.floor(plat.x + margin + R()*range);
        newLava.push({ x: lavaX, y: plat.y - 12, w: lavaW, h: 12 });
      }
    }

    if (R() < 0.35) {
      const wallH = 50 + Math.floor(R()*70);
      const margin = 90;
      const wx = Math.round(plat.x + margin + R()*(Math.max(20, plat.w - margin*2)));
      newWalls.push({x: wx, y: plat.y - wallH, w: 16, h: wallH});
    }
    if (R() < 0.20) {
      const ceilingW = 120 + Math.floor(R()*120);
      const cx = Math.round(plat.x + 30 + R()*Math.max(30, plat.w-60));
      const cy = Math.max(minY+20, plat.y - 110 - R()*40);
      newWalls.push({x: cx, y: cy, w: ceilingW, h: 14});
    }

    cursorX = plat.x + plat.w;
    cursorY = plat.y;
  }
  const maxJump = Math.floor((WORLD.jumpVel*WORLD.jumpVel)/(2*WORLD.gravity));
  const antiCheeseY = Math.min(floorY - (maxJump + 24), maxY);
  let goalDX = 120 + Math.floor(R()*120);
  const gW = 200 + Math.floor(R()*160);
  function highestReachableYFrom(y0, dx){
    let y = y0; const step = 2;
    while (y > minY + 20) {
      const dY = y - y0;
      if (maxHorizDistanceForDeltaY(dY) >= dx) { y -= step; continue; }
      break;
    }
    return Math.max(y, minY + 20);
  }
  let yReachTop = highestReachableYFrom(cursorY, goalDX);
  let adapt = 0;
  while (yReachTop > antiCheeseY && goalDX > 80 && adapt < 8) {
    goalDX -= 20;
    yReachTop = highestReachableYFrom(cursorY, goalDX);
    adapt++;
  }
  let goalYTop = Math.max(minY + 20, yReachTop);
  let goalYBottom = Math.min(antiCheeseY, cursorY + 40);
  if (goalYBottom < goalYTop) goalYBottom = goalYTop;
  const goalPlat = { x: cursorX + goalDX, y: Math.round(goalYTop + R()*(goalYBottom - goalYTop)), w: gW, h: 18 };
  segs.push(goalPlat);
  newLava.push({ x: goalPlat.x - 160, y: floorY-12, w: goalPlat.w + 320, h: 12 });
  goalX = goalPlat.x + goalPlat.w - goalW - 20;
  goalY = goalPlat.y - goalH;
  const floor = { x: -1000, y: floorY, w: cursorX+3000, h: 200 };
  segs.push(floor);
  platforms = segs.sort((a,b)=> a.x - b.x);
  walls = newWalls.sort((a,b)=> a.x - b.x);
  lavaPools = newLava.sort((a,b)=> a.x - b.x);
  startX = startPlat.x + 20;
  startY = startPlat.y - player.h;
}

function restartLocal(){
  player.x=startX; player.y=startY; player.vx=0; player.vy=0; player.onGround=false;
  finished=false; timeStart=timeNow;
  if (roomId) db.ref(`rooms/${roomId}/players/${localId}`).update({ finished:false, time:0 });
}

function physics(dt){
  const left = keys.has('ArrowLeft') || keys.has('KeyA');
  const right = keys.has('ArrowRight') || keys.has('KeyD');
  const jumpPressed = (keys.has('Space') || keys.has('KeyW') || keys.has('ArrowUp'));
  const desired = (right ? 1 : 0) - (left ? 1 : 0);
  const accel = player.onGround ? WORLD.runAccel : WORLD.runAccel*WORLD.airControl;
  player.vx += desired * accel * dt;
  if (!left && !right) {
    const fric = player.onGround ? WORLD.groundFric : WORLD.airFric;
    if (Math.abs(player.vx) <= fric*dt) player.vx = 0; else player.vx -= Math.sign(player.vx)*fric*dt;
  }
  player.vx = Math.max(-WORLD.maxSpeed, Math.min(WORLD.maxSpeed, player.vx));
  if (right) player.facing = 1; else if (left) player.facing = -1;
  player.vy += WORLD.gravity * dt;
  if (player.vy > WORLD.maxFall) player.vy = WORLD.maxFall;
  if (jumpPressed) player.lastJumpPress = timeNow;
  const canJump = (timeNow - player.lastJumpPress) <= WORLD.jumpBuffer && (player.onGround || (timeNow - player.lastGroundTime) <= WORLD.coyoteTime);
  if (canJump) { player.vy = -WORLD.jumpVel; player.onGround = false; player.lastJumpPress = -999; }
  if (!jumpPressed && player.vy < 0) player.vy += WORLD.gravity * WORLD.shortHopCut * dt;
  let newX = player.x + player.vx * dt;
  let newY = player.y + player.vy * dt;
  player.onGround = false;
  const solids = platforms.concat(walls);
  const boundsX = {x: Math.min(player.x, newX), y: player.y, w: player.w + Math.abs(player.vx*dt), h: player.h};
  for (const s of solids) {
    if (!rectsOverlap(boundsX.x,boundsX.y,boundsX.w,boundsX.h, s.x,s.y,s.w,s.h)) continue;
    if (rectsOverlap(newX, player.y, player.w, player.h, s.x,s.y,s.w,s.h)) {
      if (player.vx > 0) newX = s.x - player.w; else if (player.vx < 0) newX = s.x + s.w;
      player.vx = 0;
    }
  }
  const boundsY = {x: newX, y: Math.min(player.y, newY), w: player.w, h: player.h + Math.abs(player.vy*dt)};
  let groundedThisFrame = false;
  for (const s of solids) {
    if (!rectsOverlap(boundsY.x,boundsY.y,boundsY.w,boundsY.h, s.x,s.y,s.w,s.h)) continue;
    if (rectsOverlap(newX, newY, player.w, player.h, s.x,s.y,s.w,s.h)) {
      if (player.vy > 0) { newY = s.y - player.h; player.vy = 0; groundedThisFrame = true; }
      else if (player.vy < 0) { newY = s.y + s.h; player.vy = 0; }
    }
  }
  player.x = newX; player.y = newY;
  if (groundedThisFrame) { player.onGround = true; player.lastGroundTime = timeNow; player.landedAt = timeNow; }
  for (const l of lavaPools) { if (rectsOverlap(player.x,player.y,player.w,player.h, l.x,l.y,l.w,l.h)) { killPlayer(); break; } }
  const speed = Math.abs(player.vx);
  if (player.onGround && speed > 10) player.runCycle = (player.runCycle + dt * (0.6 + 0.004*speed)) % 1; else if (!player.onGround) player.runCycle = player.runCycle; else player.runCycle = (player.runCycle*0.92);
  if (!finished && rectsOverlap(player.x,player.y,player.w,player.h, goalX,goalY,goalW,goalH)) {
    finished = true;
    const t = timeNow - timeStart;
    timeEl.textContent = Math.max(0, t).toFixed(3);
    if (roomId) {
      db.ref(`rooms/${roomId}/players/${localId}`).update({ finished:true, time: t, name: localName, color: localColor });
      const lbRef = db.ref(`rooms/${roomId}/leaderboard/${localId}`);
      lbRef.transaction(current => {
        if (!current || typeof current.time !== 'number' || t < current.time) { return { name: localName, time: t }; }
        return current;
      });
    }
  }
}

function rippleRadius(tSinceLand){
  const k = Math.max(0, Math.min(1, tSinceLand / 0.12));
  return 10 + 70 * k;
}

function drawStick(px, py, pl, strokeColor='#e8ecf1', currentTime=null){
  const nowT = (currentTime == null) ? timeNow : currentTime;
  const t = pl.runCycle || 0, facing = pl.facing || 1;
  const hipY = py + 20;
  const swing = Math.sin(t*TAU), counter = Math.sin(t*TAU + Math.PI);
  const legA = swing * 0.9, legB = counter * 0.9, armA = counter * 1.2, armB = swing * 1.2;
  const airTilt = Math.max(-0.25, Math.min(0.25, -(pl.vy||0)/1200));
  ctx.save(); ctx.translate(px, hipY); ctx.scale(facing,1); ctx.rotate(airTilt);
  ctx.lineCap='round'; ctx.lineWidth=3; ctx.strokeStyle=strokeColor;
  drawLimb(0,0,0,18,18,legA); drawLimb(0,0,0,18,18,legB);
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-26); ctx.stroke();
  drawLimb(0,-26+6,0,14,14,armA); drawLimb(0,-26+6,0,14,14,armB);
  ctx.beginPath(); ctx.arc(0,-26-10-4,10,0,TAU); ctx.stroke();
  const tSinceLand = nowT - (pl.landedAt||-999);
  if (pl.onGround && tSinceLand >= 0 && tSinceLand < 0.12) {
    ctx.globalAlpha = 1 - (tSinceLand/0.12);
    ctx.beginPath();
    const rr = rippleRadius(tSinceLand);
    ctx.arc(0, 2, rr, 0, TAU);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  ctx.restore();
}

function drawLimb(x0,y0,offX,len1,len2,angle){
  const ax = x0 + offX + Math.cos(angle)*len1; const ay = y0 + Math.sin(angle)*len1;
  const bx = ax + Math.cos(angle+0.2)*len2; const by = ay + Math.sin(angle+0.2)*len2;
  ctx.beginPath(); ctx.moveTo(x0+offX, y0); ctx.lineTo(ax, ay); ctx.lineTo(bx, by); ctx.stroke();
}

function draw(){
  const cw = VIEW_W, ch = VIEW_H;
  const camX = Math.floor(player.x - cw*0.35);
  const camY = 0;
  const grd = ctx.createLinearGradient(0,0,0,ch);
  grd.addColorStop(0, '#0f1222'); grd.addColorStop(1, '#12162a');
  ctx.fillStyle = grd; ctx.fillRect(0,0,cw,ch);
  ctx.globalAlpha = 0.25; ctx.fillStyle = '#b6c4ff';
  for (let i=0;i<80;i++) { const sx = (i*1231.7 % 3000) - (camX*0.2 % 3000); const sy = (i*811.3 % ch); ctx.fillRect((sx% (cw+300))-150, sy, 2, 2); }
  ctx.globalAlpha = 1;
  for (const p of platforms) { if (p.x + p.w < camX-50 || p.x > camX+cw+50) continue; const x = p.x - camX, y = p.y - camY; ctx.fillStyle = '#222947'; ctx.fillRect(x, y, p.w, p.h); ctx.fillStyle = '#2e3763'; ctx.fillRect(x, y, p.w, 4); }
  for (const w of walls) { if (w.x + w.w < camX-50 || w.x > camX+cw+50) continue; const x = w.x - camX, y = w.y - camY; ctx.fillStyle = '#1a1f3a'; ctx.fillRect(x, y, w.w, w.h); ctx.fillStyle = '#34406e'; ctx.fillRect(x, y, w.w, 4); }
  for (const l of lavaPools) {
    if (l.x + l.w < camX-50 || l.x > camX+cw+50) continue;
    const x = l.x - camX, y = l.y - camY; const t = timeNow*5;
    const grad = ctx.createLinearGradient(0,y,0,y+l.h);
    grad.addColorStop(0,'#ffdb6e'); grad.addColorStop(0.4,'#ff7b3a'); grad.addColorStop(1,'#b1120d');
    ctx.fillStyle = grad; ctx.fillRect(x, y, l.w, l.h);
    ctx.beginPath(); const waveAmp = 3; ctx.moveTo(x, y);
    for (let i=0;i<=l.w;i+=8){ const wy = y + Math.sin((i*0.12)+t)*waveAmp; ctx.lineTo(x+i, wy); }
    ctx.lineTo(x+l.w, y+l.h); ctx.lineTo(x, y+l.h); ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fill();
  }
  ctx.fillStyle = finished ? '#3bd16f' : '#ffcf4b';
  ctx.fillRect(goalX - camX, goalY - camY, goalW, goalH);
  ctx.fillStyle = '#e8ecf1';
  ctx.fillRect(goalX - camX + goalW/2-2, goalY - 50 - camY, 4, 50);
  ctx.beginPath(); ctx.moveTo(goalX - camX + goalW/2+2, goalY - 50 - camY);
  ctx.lineTo(goalX - camX + goalW/2+32, goalY - 40 - camY); ctx.lineTo(goalX - camX + goalW/2+2, goalY - 30 - camY);
  ctx.closePath(); ctx.fill();
  drawStick(player.x - camX + player.w/2, player.y - camY, player, localColor);
  ctx.save(); ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign = 'center'; ctx.fillStyle = localColor; ctx.fillText((localName||'You').slice(0,14), player.x - camX + player.w/2, player.y - camY - 56); ctx.restore();
  for (const [pid, p] of Object.entries(players)) {
    if (pid === localId) continue;
    const ghost = { x:p.x||0, y:p.y||0, w:20, h:52, vx:p.vx||0, vy:p.vy||0, onGround: Math.abs((p.vy||0))<1, runCycle:0, facing:(p.vx||0)>0?1:-1, landedAt: -999 };
    drawStick(ghost.x - camX + 10, ghost.y - camY, ghost, p.color||'#b6c4ff');
    ctx.save(); ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial'; ctx.textAlign = 'center'; ctx.fillStyle = p.color || '#b6c4ff'; ctx.fillText((p.name||'Player').slice(0,14), ghost.x - camX, ghost.y - camY - 56); ctx.restore();
  }
  const displayTime = finished ? (timeNow - timeStart) : Math.max(0, timeNow - timeStart);
  timeEl.textContent = displayTime.toFixed(3);
  if (timeNow < deathFlashUntil) { ctx.fillStyle = 'rgba(255,80,60,0.35)'; ctx.fillRect(0,0,cw,ch); }
}

let lastRAF = performance.now();
let lastSync = 0;
function loop(now){
  const dtRaw = (now - lastRAF) / 1000; lastRAF = now; const dt = Math.min(1/30, Math.max(0, dtRaw));
  timeNow += dt; if (!timeStart) timeStart = timeNow; physics(dt); draw();
  if (roomId && (now - lastSync) > 100) { lastSync = now; db.ref(`rooms/${roomId}/players/${localId}`).update({ name: localName, color: localColor, x: player.x, y: player.y, vx: player.vx, vy: player.vy }); }
  requestAnimationFrame(loop);
}

function startGame(){ seedEl.textContent = seed; generateLevel(seed); restartLocal(); requestAnimationFrame(loop); }

addEventListener('beforeunload', ()=>{ if (roomId) { try { db.ref(`rooms/${roomId}/players/${localId}`).remove(); } catch(e){} } });

startPractice();

/* -------------------------------- Self-tests (dev) --------------------------------
Run by appending ?test=1 to the URL. These are sanity checks to catch syntax/logic
issues like stray braces or redeclarations without altering gameplay. */
(function selfTests(){
  try {
    const params = new URLSearchParams(location.search);
    if (params.get('test') !== '1') return;
    console.log('[TEST] starting');
    (function(){ const payload = { seed:123, hostId:'abc', started:true, leaderboard:{} }; const ok = payload.seed===123 && payload.hostId==='abc' && payload.started===true && typeof payload.leaderboard==='object'; console.assert(ok, 'createRoom payload shape invalid'); })();
    (function(){ let threw = false; try { generateLevel(42); } catch(e){ threw = true; } console.assert(!threw, 'generateLevel should not throw'); })();
    console.assert(typeof hostNewLevel === 'function', 'hostNewLevel should be defined');
    (function(){ const r1 = rippleRadius(-5), r2 = rippleRadius(0), r3 = rippleRadius(0.12), r4 = rippleRadius(1); console.assert(r1 >= 10 && r2 >= 10 && r3 >= 10 && r4 >= 10, 'ripple radius should never be negative'); })();
    // New test: world scaling deterministic regardless of window
    (function(){ const h = WORLD_H; console.assert(h === 900, 'WORLD_H should be constant for all clients'); })();
    // Scoring tests
    (function(){
      const players = { a:{name:'A'}, b:{name:'B'}, c:{name:'C'} };
      const lb = { a:{name:'A', time: 5}, c:{name:'C', time: 9} };
      const out = calculateRoundPoints(players, lb, {});
      console.assert(out.a.points===1 && out.c.points===2 && out.b.points===3, 'scoring logic failed');
    })();
    console.log('[TEST] passed');
  } catch (e) { console.error('[TEST] failed', e); }
})();
</script>
</body>
</html>
