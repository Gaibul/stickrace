<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stick Parkour Online — Procedural</title>
<style>
  :root { --bg:#0b0e14; --fg:#e6edf3; --muted:#9aa4b2; --accent:#6ae3ff; --good:#7efc9a; --warn:#ffbe55; }
  * { box-sizing: border-box; }
  body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:var(--bg); color:var(--fg); }
  header { display:flex; gap:12px; align-items:end; padding:12px 12px 0; flex-wrap:wrap; }
  fieldset { border:1px solid #1f2430; border-radius:12px; padding:10px 12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  legend { color:var(--muted); font-size:12px; padding:0 6px; }
  input, button { background:#121722; color:var(--fg); border:1px solid #232939; border-radius:10px; padding:8px 10px; }
  input::placeholder { color:#5b6474; }
  button { cursor:pointer; }
  button.primary { background:#152235; border-color:#274067; }
  #canvasWrap { position:relative; width:100vw; height:calc(100vh - 120px); }
  canvas { display:block; width:100%; height:100%; background:linear-gradient(#0a0f1c, #0b0e14 30%); }
  #hud { position:absolute; top:10px; left:10px; padding:8px 10px; background:rgba(10,14,20,.55); border:1px solid rgba(255,255,255,.07); border-radius:10px; font-size:12px; backdrop-filter: blur(6px); }
  #log { max-height:6lh; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; opacity:.9; }
  .pill { padding:4px 8px; border-radius:999px; border:1px solid #263045; }
  a { color:var(--accent); text-decoration: none; }
  .badge { border:1px solid #2a3246; background:#141b28; color:#b9c2cf; padding:2px 8px; border-radius:999px; font-size:11px; }
</style>
</head>
<body>
<header>
  <fieldset>
    <legend>Identity</legend>
    <label> Name <input id="name" placeholder="your nickname" maxlength="18"/> </label>
    <span class="badge" id="youId">offline</span>
  </fieldset>
  <fieldset>
    <legend>Room</legend>
    <label> Room ID <input id="room" placeholder="e.g. park-1234" maxlength="24"/></label>
    <button id="create" class="primary">Create</button>
    <button id="join">Join</button>
    <button id="leave">Leave</button>
    <span class="badge" id="roomStatus">no room</span>
  </fieldset>
  <fieldset>
    <legend>Options</legend>
    <button id="spectate">Spectate</button>
    <button id="respawn">Respawn</button>
    <button id="newRound" class="primary">New Round</button>
    <span class="pill">W/▲/Space = jump · A/D or ◄/► = move</span>
    <span class="badge" id="roundSeed">seed: —</span>
  </fieldset>
</header>

<div id="canvasWrap">
  <canvas id="game" width="1280" height="720"></canvas>
  <div id="hud">
    <div><strong>Stick Parkour Online</strong> · <span id="fps">—</span> FPS · <span id="players">0</span> players</div>
    <div id="log"></div>
  </div>
</div>

<!-- Firebase (compat CDN so this runs as a single HTML file) -->
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-analytics-compat.js"></script>

<script>
/* =========================
   0) Firebase Setup
========================= */
const firebaseConfig = {
  apiKey: "AIzaSyAEqutXCO5OZD6VU_ohaBxNfh7G8Q6PEy0",
  authDomain: "nomercy-8269a.firebaseapp.com",
  databaseURL: "https://nomercy-8269a-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "nomercy-8269a",
  storageBucket: "nomercy-8269a.firebasestorage.app",
  messagingSenderId: "349047620790",
  appId: "1:349047620790:web:3206ff81cb7f5413d29217",
  measurementId: "G-1WX7CWBFGF"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const auth = firebase.auth();
try { firebase.analytics(); } catch(e) { /* ignored */ }

/* =========================
   1) Helpers & state
========================= */
const $ = sel => document.querySelector(sel);
const logBox = $('#log');
const log = (msg) => { const el = document.createElement('div'); el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`; logBox.prepend(el); };
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t)=> a+(b-a)*t;

let me = { uid:null, name:"", room:null, spectating:false };
let players = new Map(); // uid -> {name, state, lastNet}
let platforms = [];      // current course
let courseStart = {x:40, y:-40};
let local = {
  w: 22, h: 48,
  pos: {x: 0, y: 0},
  vel: {x: 0, y: 0},
  onGround:false,
  onWall:0,
  jumps:0,
  _jumpHeld:false,
};
let camera = {x:0, y:0};
let keys = new Set();
let inRoom = false;
let myRef = null;
let tick = 0;

// round sync & rng + anim/physics timers
let round = { seed: null };
let rngState = 1;
let runPhase = 0;
let coyoteTimer = 0;
let jumpBufferTimer = 0;

/* =========================
   2) UI
========================= */
$('#name').value = localStorage.getItem('sp_name') || "";
$('#name').addEventListener('input', e=>{
  me.name = e.target.value.trim() || "Guest";
  localStorage.setItem('sp_name', me.name);
  updateMyNameInRoom();
});
$('#room').value = localStorage.getItem('sp_room') || "";
$('#room').addEventListener('input', e=> localStorage.setItem('sp_room', e.target.value.trim() ));

$('#create').onclick = async ()=>{
  const id = roomId();
  $('#room').value = id;
  localStorage.setItem('sp_room', id);
  await joinRoom(id, true);
};
$('#join').onclick = async ()=> joinRoom(roomId(), false);
$('#leave').onclick = async ()=> leaveRoom();
$('#spectate').onclick = ()=> { me.spectating = !me.spectating; $('#spectate').textContent = me.spectating ? 'Playing' : 'Spectate'; };
$('#respawn').onclick = ()=> respawn();

/* =========================
   3) Auth
========================= */
auth.signInAnonymously().then(cred=>{
  me.uid = cred.user.uid;
  $('#youId').textContent = me.uid.slice(0,6);
  me.name = ($('#name').value.trim()) || "Guest";
  log("Signed in anonymously.");
}).catch(err=>{ console.error(err); log("Auth error. Check Firebase config & allowed domains."); });

/* =========================
   4) Controls & Canvas
========================= */
window.addEventListener('keydown', e=>{
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
  keys.add(e.key.toLowerCase());
});
window.addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });
const fit = ()=> {
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const w = canvas.clientWidth * dpr, h = canvas.clientHeight * dpr;
  if (canvas.width!==w || canvas.height!==h) { canvas.width=w; canvas.height=h; }
};
window.addEventListener('resize', fit); fit();

/* =========================
   5) Procedural course (deterministic)
========================= */
function seedRng(s){ rngState = (s>>>0) || 1; }
function rand(){ let x = rngState; x ^= x << 13; x ^= x >>> 17; x ^= x << 5; rngState = x>>>0; return (rngState/4294967296); }

function computeJumpStats(){
  const airTime = 2 * JUMP_V / GRAVITY;        // total airtime
  const safeHoriz = MAX_SPEED * airTime * 0.9; // safety margin
  const maxRise = (JUMP_V*JUMP_V)/(2*GRAVITY) * 0.85;
  const maxDrop = 260;
  return { maxGapX: safeHoriz, maxRise, maxDrop };
}

function generateCourse(seed){
  seedRng(seed || 1);
  platforms = [];
  const groundY = 420;
  // base ground strip
  platforms.push({x:-2000, y:groundY, w:5000, h:48, type:'ground'});

  const { maxGapX, maxRise, maxDrop } = computeJumpStats();
  const minGap = 80;
  const maxGap = Math.min(320, maxGapX);
  const maxStepUp = Math.min(maxRise*0.9, 220);
  const maxStepDown = Math.min(maxDrop, 360);

  // start platform
  let x = 40, y = groundY-80;
  const startW = 160, startH = 20;
  platforms.push({x:x- startW/2, y:y, w:startW, h:startH, type:'start'});
  courseStart = {x, y: y-4};

  // chain of ledges
  const count = 18 + Math.floor(rand()*6);
  for (let i=0;i<count;i++){
    const gap = minGap + rand()*(maxGap-minGap);
    const step = (rand()<0.5 ? -1:1) * (rand()<0.6 ? rand()*maxStepUp : rand()*maxStepDown*0.6);
    x += gap + 80*(rand()-0.5); // slight jitter
    y = clamp(y + step, groundY-300, groundY-40);
    const w = 110 + rand()*120, h = 20;
    platforms.push({x:x - w/2, y, w, h, type:'ledge'});

    // optional walls for style routes (not required to finish)
    if (rand()<0.25){
      const wallH = 180 + rand()*140;
      platforms.push({x:x + w/2 + 20, y:y - wallH, w:18, h:wallH, type:'wall'});
    }
  }

  // goal
  const last = platforms.filter(p=>p.type==='ledge').slice(-1)[0] || {x:x-80, y:y, w:160};
  const goalX = last.x + last.w + 260;
  const goalY = Math.min(last.y+40, groundY-60);
  platforms.push({x:goalX-120, y:goalY, w:160, h:20, type:'goal'});
}

function buildCourse(){ generateCourse(round.seed || 12345); }
buildCourse();

/* =========================
   6) Physics (with jump buffer, coyote, variable jump)
========================= */
const GRAVITY = 1800;
const MOVE_ACCEL = 9800;
const AIR_ACCEL  = 6200;
const MAX_SPEED  = 360;
const JUMP_V     = 640;
const WALL_SLIDE = 220;
const FRICTION   = 2200;
const AIR_DRAG   = 0.06;
const COYOTE_TIME = 0.08; // s
const JUMP_BUFFER = 0.12; // s
const JUMP_CUT = 0.45;    // early release dampen

function respawn(){
  local.pos.x = courseStart.x;
  local.pos.y = courseStart.y;
  local.vel.x = 0;
  local.vel.y = 0;
  local.onGround=false;
  local.onWall=0;
  local.jumps=0;
  coyoteTimer = 0; jumpBufferTimer = 0;
  log("Respawned.");
}
respawn();

function aabb(a,b){ return !(a.x+a.w<=b.x || a.x>=b.x+b.w || a.y+a.h<=b.y || a.y>=b.y+b.h); }

function step(dt){
  const left  = keys.has('a') || keys.has('arrowleft');
  const right = keys.has('d') || keys.has('arrowright');
  const jumpKey  = keys.has('w') || keys.has('arrowup') || keys.has(' ');

  // input timers
  if (jumpKey){ jumpBufferTimer = JUMP_BUFFER; } else { jumpBufferTimer = Math.max(0, jumpBufferTimer - dt); }

  // horizontal accel
  const targetAccel = local.onGround ? MOVE_ACCEL : AIR_ACCEL;
  if (left ^ right){
    local.vel.x += (left ? -1 : 1) * targetAccel * dt;
  } else {
    if (local.onGround){
      const sign = Math.sign(local.vel.x);
      const mag = Math.max(0, Math.abs(local.vel.x) - FRICTION*dt);
      local.vel.x = mag * sign;
    } else {
      local.vel.x *= (1 - AIR_DRAG);
    }
  }
  local.vel.x = clamp(local.vel.x, -MAX_SPEED, MAX_SPEED);

  // gravity
  local.vel.y += GRAVITY * dt;

  // wall slide
  if (!local.onGround && local.onWall!==0 && local.vel.y>WALL_SLIDE){
    local.vel.y = WALL_SLIDE;
  }

  // coyote time & jumping
  if (local.onGround) coyoteTimer = COYOTE_TIME; else coyoteTimer = Math.max(0, coyoteTimer - dt);
  if (jumpBufferTimer>0 && (coyoteTimer>0 || local.onWall!==0)){
    if (local.onWall!==0){
      local.vel.y = -JUMP_V * 0.95;
      local.vel.x = (local.onWall===-1 ? 1 : -1) * MAX_SPEED * 0.9;
      local.onWall = 0;
    } else {
      local.vel.y = -JUMP_V;
    }
    local.onGround=false;
    local.jumps=1;
    jumpBufferTimer = 0;
  }

  // variable jump height
  if (!jumpKey && local.vel.y < 0){
    local.vel.y *= JUMP_CUT;
  }

  // integrate X then resolve
  local.pos.x += local.vel.x * dt;
  resolveCollisionsAxis('x');

  // integrate Y then resolve
  local.onGround = false; local.onWall = 0;
  local.pos.y += local.vel.y * dt;
  resolveCollisionsAxis('y');

  // animation phase
  const speedNorm = clamp(Math.abs(local.vel.x)/MAX_SPEED, 0, 1);
  runPhase += (6 + 6*speedNorm) * dt * (local.onGround?1:0.4);

  // bounds
  if (local.pos.y > 2000) respawn();

  // goal check
  const body = {x:local.pos.x- local.w/2, y:local.pos.y- local.h, w:local.w, h:local.h};
  for (const p of platforms){
    if (p.type==='goal' && aabb(body,p)){
      log("🎉 You reached the goal!");
      break;
    }
  }
}

function resolveCollisionsAxis(axis){
  const body = {x:local.pos.x- local.w/2, y:local.pos.y- local.h, w:local.w, h:local.h};
  for (const p of platforms){
    if (!aabb(body,p)) continue;
    if (axis==='x'){
      if (local.vel.x>0){ body.x = p.x - body.w - 0.01; local.vel.x = 0; local.onWall = +1; }
      else if (local.vel.x<0){ body.x = p.x + p.w + 0.01; local.vel.x = 0; local.onWall = -1; }
      local.pos.x = body.x + body.w/2;
    } else {
      if (local.vel.y>0){ body.y = p.y - body.h - 0.01; local.vel.y = 0; local.onGround = true; }
      else if (local.vel.y<0){ body.y = p.y + p.h + 0.01; local.vel.y = 10; }
      local.pos.y = body.y + body.h;
    }
  }
}

/* =========================
   7) Rendering (with run cycle)
========================= */
function draw(){
  const w = canvas.width, h = canvas.height;
  camera.x = lerp(camera.x, local.pos.x - w*0.5, 0.08);
  camera.y = lerp(camera.y, local.pos.y - h*0.6, 0.08);

  ctx.clearRect(0,0,w,h);

  // parallax dots
  ctx.save();
  ctx.translate(-camera.x*0.2, -camera.y*0.2);
  ctx.globalAlpha = 0.15;
  for (let i=0;i<50;i++){
    ctx.fillStyle = "#6ae3ff";
    ctx.fillRect((i*349)%5000, (i*997)%2000, 3,3);
  }
  ctx.restore();

  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  for (const p of platforms){
    if (p.type==='ground'){ ctx.fillStyle="#1a2030"; }
    else if (p.type==='wall'){ ctx.fillStyle="#24314a"; }
    else if (p.type==='goal'){ ctx.fillStyle="#19361f"; }
    else if (p.type==='start'){ ctx.fillStyle="#253047"; }
    else if (p.type==='nub'){ ctx.fillStyle="#273049"; }
    else { ctx.fillStyle="#222a3f"; }
    roundRect(ctx, p.x, p.y, p.w, p.h, 6, true);

    if (p.type==='goal'){
      ctx.strokeStyle="#7efc9a"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(p.x+p.w-24, p.y); ctx.lineTo(p.x+p.w-24, p.y-38); ctx.stroke();
      ctx.fillStyle="#7efc9a";
      ctx.beginPath(); ctx.moveTo(p.x+p.w-24, p.y-38); ctx.lineTo(p.x+p.w-4, p.y-30); ctx.lineTo(p.x+p.w-24, p.y-22); ctx.closePath(); ctx.fill();
    }
  }

  // remote players
  for (const [uid, pl] of players){
    if (uid===me.uid) continue;
    drawStick(pl.drawX ?? pl.state.x, pl.drawY ?? pl.state.y, pl.state.facing, pl.color || "#9bd1ff", pl.name);
  }

  // local player
  drawStick(local.pos.x, local.pos.y, Math.sign(local.vel.x)||1, "#ffd68a", me.name || "You");

  ctx.restore();
}

function drawStick(cx, cy, facing, color, name){
  ctx.save();
  ctx.translate(cx, cy);
  ctx.strokeStyle = color; ctx.fillStyle=color; ctx.lineWidth = 3;

  // head & torso
  ctx.beginPath(); ctx.arc(0, -local.h+12, 9, 0, Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, -local.h+22); ctx.lineTo(0, -20); ctx.stroke();

  // run cycle (speed-scaled, mirrored by direction)
  const speedNorm = clamp(Math.abs(local.vel.x)/MAX_SPEED,0,1);
  const phase = runPhase * (local.vel.x>=0?1:-1);
  const legA = Math.sin(phase) * 10 * (local.onGround?1:0.4);
  const legB = -Math.sin(phase) * 10 * (local.onGround?1:0.4);
  const armA = -Math.sin(phase) * 12 * (local.onGround?1:0.4);
  const armB = Math.sin(phase) * 12 * (local.onGround?1:0.4);

  // arms
  ctx.beginPath(); ctx.moveTo(0, -local.h+28); ctx.lineTo(armA, -local.h+46); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, -local.h+28); ctx.lineTo(armB, -local.h+46); ctx.stroke();

  // legs
  ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(8+legA, 0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-8+legB, 0); ctx.stroke();

  // nameplate
  ctx.font = "12px ui-sans-serif, system-ui";
  ctx.textAlign="center"; ctx.textBaseline="bottom";
  ctx.fillStyle = "rgba(0,0,0,.35)";
  roundRect(ctx, -34, -local.h-18, 68, 16, 8, true);
  ctx.fillStyle=color;
  ctx.fillText(name || "player", 0, -local.h-6);
  ctx.restore();
}

function roundRect(ctx,x,y,w,h,r,fill){
  const rr=Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  if (fill) ctx.fill(); else ctx.stroke();
}

/* =========================
   8) Networking (players + round seed sync)
========================= */
function roomId(){
  const v = ($('#room').value.trim() || "").toLowerCase();
  return v || `park-${Math.floor(Math.random()*9000+1000)}`;
}

async function joinRoom(id, creating){
  if (!me.uid){ log("Wait: not signed in yet."); return; }
  if (!id){ log("Enter a room id."); return; }
  if (inRoom && me.room===id){ log("Already in this room."); return; }
  await leaveRoom();

  const metaRef = db.ref(`rooms/${id}/meta`);
  if (creating){ await metaRef.update({ createdAt: firebase.database.ServerValue.TIMESTAMP }); }

  // round seed sync
  const roundRef = db.ref(`rooms/${id}/round`);
  const newSeed = Math.floor((Date.now() ^ Math.random()*1e9)>>>0);
  const snap = await roundRef.get();
  if (!snap.exists()){
    await roundRef.set({ seed: newSeed, ts: firebase.database.ServerValue.TIMESTAMP });
  }
  roundRef.on('value', s=>{
    const v = s.val(); if (!v) return;
    round.seed = v.seed>>>0;
    $('#roundSeed').textContent = `seed: ${round.seed}`;
    generateCourse(round.seed);
    respawn();
  });

  // presence
  myRef = db.ref(`rooms/${id}/players/${me.uid}`);
  const presence = { name: me.name || "Guest", x: local.pos.x, y: local.pos.y, facing: 1, t: firebase.database.ServerValue.TIMESTAMP };
  await myRef.set(presence);
  await myRef.onDisconnect().remove();

  const pRef = db.ref(`rooms/${id}/players`);
  pRef.on('child_added', snap=>{
    const uid = snap.key; const v = snap.val();
    if (!players.has(uid)) players.set(uid, {name:v.name, color: colorFor(uid), state:{x:v.x, y:v.y, facing:v.facing}, drawX:v.x, drawY:v.y, lastNet:performance.now()});
    updateCounts();
  });
  pRef.on('child_changed', snap=>{
    const uid = snap.key; const v = snap.val();
    const pl = players.get(uid) || {name:v.name, color: colorFor(uid), state:{}};
    pl.name = v.name;
    pl.prev = pl.state;
    pl.state = { x:v.x, y:v.y, facing:v.facing };
    pl.lastNet = performance.now();
    players.set(uid, pl);
  });
  pRef.on('child_removed', snap=>{ players.delete(snap.key); updateCounts(); });

  me.room = id; inRoom = true;
  $('#roomStatus').textContent = `in ${id}`;
  log(`Joined room "${id}". Share this Room ID with friends.`);
  updateMyNameInRoom();
  updateCounts();
}

async function leaveRoom(){
  if (!inRoom) return;
  const id = me.room;
  db.ref(`rooms/${id}/players`).off();
  db.ref(`rooms/${id}/round`).off();
  if (myRef){ try{ await myRef.remove(); }catch(e){}}
  players.clear(); myRef = null; me.room = null; inRoom=false; $('#roomStatus').textContent='no room'; updateCounts();
  log("Left room.");
}

function updateMyNameInRoom(){ if (inRoom && myRef){ myRef.update({ name: me.name || "Guest" }); } }

function colorFor(uid){
  let h=0; for (let i=0;i<uid.length;i++) h = (h*31 + uid.charCodeAt(i))>>>0;
  const hue = h % 360;
  return `hsl(${hue} 90% 70%)`;
}

// Push my state
setInterval(()=>{
  if (!inRoom || !myRef || me.spectating) return;
  myRef.update({ x: local.pos.x, y: local.pos.y, facing: Math.sign(local.vel.x) || 1, t: firebase.database.ServerValue.TIMESTAMP, name: me.name || "Guest" });
}, 100);

// Interpolate others
function interpolateRemotes(){
  const now = performance.now();
  for (const [uid, pl] of players){
    if (uid===me.uid) continue;
    const alpha = clamp((now - (pl.lastNet||now)) / 120, 0, 1);
    pl.drawX = lerp(pl.drawX ?? pl.state.x, pl.state.x, 0.18 + 0.4*alpha);
    pl.drawY = lerp(pl.drawY ?? pl.state.y, pl.state.y, 0.18 + 0.4*alpha);
  }
}

/* =========================
   9) Loop
========================= */
let acc = 0, lastT = performance.now();
let frames=0, fps=0, lastFpsT=performance.now();

function loop(t){
  const dtRaw = (t - lastT)/1000; lastT = t; acc += dtRaw;
  const fixed = 1/60;
  while (acc >= fixed){ if (!me.spectating) step(fixed); acc -= fixed; }
  interpolateRemotes();
  draw();
  tick++;

  frames++; const now=performance.now();
  if (now-lastFpsT>=500){ fps = Math.round(frames*1000/(now-lastFpsT)); frames=0; lastFpsT=now; $('#fps').textContent=fps; }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =========================
   10) QoL & Round controls
========================= */
document.getElementById('newRound').onclick = async ()=>{
  if (!inRoom){ log('Join a room first.'); return; }
  const roundRef = db.ref(`rooms/${me.room}/round`);
  const seed = Math.floor((Date.now() ^ Math.random()*1e9)>>>0);
  await roundRef.set({ seed, ts: firebase.database.ServerValue.TIMESTAMP });
  log(`New round started (seed ${seed}).`);
};

document.addEventListener('visibilitychange', ()=>{ if (document.hidden) keys.clear(); });

</script>
</body>
</html>
